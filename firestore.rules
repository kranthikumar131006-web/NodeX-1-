
/**
 * This ruleset enforces a security model based on strict user ownership and public
 * read-access for community-focused data.
 *
 * Core Philosophy:
 * - A user has complete control over their own data.
 * - Publicly listed data (like hackathons and startups) is readable by anyone
 *   to encourage discovery, but write access is restricted to the document owner.
 * - Collaborative data (like teams) is accessible only to its members.
 *
 * Data Structure:
 * - All private user data, including distinct `studentProfiles` and
 *   `clientProfiles`, is nested under the `/users/{userId}` path. This
 *   leverages path-based security to ensure data privacy.
 * - Top-level collections like `/hackathons` and `/startups` are used for
 *   data intended for public consumption.
 * - Team data is nested under its parent hackathon at
 *   `/hackathons/{hackathonId}/teams/{teamId}`.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is granted explicitly.
 * - No User Listing: It is not possible to list all documents in the `/users`
 *   collection, protecting user privacy.
 * - Owner-Only Writes: Writes to public data collections like hackathons and
 *   startups are restricted to the user who created them, identified by a `userId` field.
 *
 * Denormalization for Authorization:
 * - The rules for `/hackathons/{hackathonId}/teams/{teamId}` rely on the
 *   `memberIds` array being denormalized directly onto the team document. This
 *   allows for an efficient check to see if a user is a member of a team
 *   without needing extra database reads.
 *
 * Structural Segregation:
 * - The separation of `studentProfiles` and `clientProfiles` into different
 *   subcollections under a user's document allows for distinct security logic
 *   and data shapes for each profile type, while still being protected under
 *   the same user-ownership model.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user's UID matches the document's path ID.
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Checks if the requesting user is the owner based on a 'userId' field in the document.
    function isDocumentOwner() {
      return isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Checks if a document currently exists. Crucial for safe updates and deletes.
    function isExistingDoc() {
      return resource != null;
    }

    // Enforces immutability for a given field during an update.
    function fieldIsImmutable(field) {
      return request.resource.data[field] == resource.data[field];
    }
    
    // On create, checks if the requesting user is in the new team's member list.
    function isTeamMemberOnCreate() {
      return isSignedIn() && request.auth.uid in request.resource.data.memberIds;
    }
    
    // On read/update/delete, checks if the requesting user is in the existing team's member list.
    function isExistingTeamMember() {
      return isSignedIn() && request.auth.uid in resource.data.memberIds;
    }

    /**
     * @description Manages a user's core account data.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own user document: `create /users/user123`
     * @deny (create) An authenticated user trying to create a document for someone else: `create /users/user456`
     * @principle A user can create and manage their own root document, but cannot access others'.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users for privacy
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDoc() && fieldIsImmutable('id');
      allow delete: if false; // Deleting user root documents is a sensitive operation, disable by default.
    }

    /**
     * @description Secures a user's student-specific profile information.
     * @path /users/{userId}/studentProfiles/{studentProfileId}
     * @allow (read, write) A user accessing their own student profile: `get /users/user123/studentProfiles/profileABC`
     * @deny (read, write) A user trying to access another user's profile: `get /users/user456/studentProfiles/profileXYZ`
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /users/{userId}/studentProfiles/{studentProfileId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) 
                      && studentProfileId == userId
                      && request.resource.data.userId == userId
                      && request.resource.data.id == userId;
      allow update: if isOwner(userId) 
                      && isExistingDoc()
                      && studentProfileId == userId
                      && fieldIsImmutable('userId')
                      && fieldIsImmutable('id');
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Secures a user's client-specific profile information.
     * @path /users/{userId}/clientProfiles/{clientProfileId}
     * @allow (read, write) A user accessing their own client profile: `get /users/user123/clientProfiles/profileABC`
     * @deny (read, write) A user trying to access another user's profile: `get /users/user456/clientProfiles/profileXYZ`
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /users/{userId}/clientProfiles/{clientProfileId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) 
                      && clientProfileId == userId
                      && request.resource.data.userId == userId
                      && request.resource.data.id == userId;
      allow update: if isOwner(userId) 
                      && isExistingDoc() 
                      && clientProfileId == userId
                      && fieldIsImmutable('userId')
                      && fieldIsImmutable('id');
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Stores public hackathon event information.
     * @path /hackathons/{hackathonId}
     * @allow (read) Any user, signed in or not, can read hackathon details.
     * @allow (write) Only the authenticated user who created the hackathon can write to it.
     * @principle Data is public-read. Writes are owner-only.
     */
    match /hackathons/{hackathonId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isExistingDoc() && isDocumentOwner();
    }

    /**
     * @description Manages teams within a specific hackathon.
     * @path /hackathons/{hackathonId}/teams/{teamId}
     * @allow (update) A team member updating their team description: `update /hackathons/h123/teams/t456`
     * @deny (update) A non-member trying to update a team: `update /hackathons/h123/teams/t456`
     * @principle Enforces shared access; only users listed in the `memberIds` array can read or write team data.
     */
    match /hackathons/{hackathonId}/teams/{teamId} {
      allow get: if isExistingTeamMember();
      allow list: if true; // Allow public listing of teams within a hackathon for discoverability.
      allow create: if isTeamMemberOnCreate() && request.resource.data.hackathonId == hackathonId;
      allow update: if isExistingDoc() && isExistingTeamMember() && fieldIsImmutable('hackathonId');
      allow delete: if isExistingDoc() && isExistingTeamMember();
    }

    /**
     * @description Stores public information about startups.
     * @path /startups/{startupId}
     * @allow (read) Any user, signed in or not, can view startup profiles.
     * @allow (write) Only the authenticated user who created the startup can write to it.
     * @principle Data is public-read. Writes are owner-only.
     */
    match /startups/{startupId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isExistingDoc() && isDocumentOwner();
    }

    /**
     * @description Stores public profiles for team members, linkable to multiple startups.
     * @path /team_members/{teamMemberId}
     * @allow (read) Any user, signed in or not, can view team member profiles.
     * @allow (write) Only the authenticated user associated with the team member profile can write to it.
     * @principle Data is public-read. Writes are owner-only.
     */
    match /team_members/{teamMemberId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isExistingDoc() && isDocumentOwner();
    }
  }
}

    