
/**
 * This ruleset enforces a security model based on strict user ownership and public
 * read-access for community-focused data.
 *
 * Core Philosophy:
 * - A user has complete control over their own data.
 * - Publicly listed data (like hackathons, startups, and profiles) is readable by anyone
 *   to encourage discovery, but write access is restricted to the document owner.
 * - Collaborative data (like teams) is accessible only to its members.
 *
 * Data Structure:
 * - `/users/{userId}` stores primary authentication info.
 * - `/studentProfiles/{profileId}` and `/clientProfiles/{profileId}` are top-level
 *   collections for easy public listing. Security is enforced via a `userId` field.
 * - Top-level collections like `/hackathons` and `/startups` are used for
 *   data intended for public consumption.
 * - Team data is nested under its parent hackathon at
 *   `/hackathons/{hackathonId}/teams/{teamId}`.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is granted explicitly.
 * - No User Listing: It is not possible to list all documents in the `/users`
 *   collection, protecting user privacy.
 * - Owner-Only Writes: Writes to all data collections are restricted to the
 *   user who created them, identified by a `userId` field in the document.
 *
* Denormalization for Authorization:
 * - The rules for `/hackathons/{hackathonId}/teams/{teamId}` rely on the
 *   `memberIds` array being denormalized directly onto the team document. This
 *   allows for an efficient check to see if a user is a member of a team
 *   without needing extra database reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user's UID matches the document's path ID.
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Checks if the requesting user is the owner based on a 'userId' field in the document.
    function isDocumentOwner() {
      return isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Checks if a document currently exists. Crucial for safe updates and deletes.
    function isExistingDoc() {
      return resource != null;
    }

    // Enforces immutability for a given field during an update.
    function fieldIsImmutable(field) {
      return request.resource.data[field] == resource.data[field];
    }
    
    // On create, checks if the requesting user is in the new team's member list.
    function isTeamMemberOnCreate() {
      return isSignedIn() && request.auth.uid in request.resource.data.memberIds;
    }
    
    // On read/update/delete, checks if the requesting user is in the existing team's member list.
    function isExistingTeamMember() {
      return isSignedIn() && request.auth.uid in resource.data.memberIds;
    }

    /**
     * @description Manages a user's core account data.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own user document: `create /users/user123`
     * @deny (create) An authenticated user trying to create a document for someone else: `create /users/user456`
     * @principle A user can create and manage their own root document, but cannot access others'.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users for privacy
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDoc() && fieldIsImmutable('id');
      allow delete: if false; // Deleting user root documents is a sensitive operation, disable by default.
    }

    /**
     * @description Secures student-specific profile information. Publicly readable for discovery.
     * @path /studentProfiles/{studentProfileId}
     * @principle Data is public-read. Writes are owner-only.
     */
    match /studentProfiles/{studentProfileId} {
      allow get, list: if true;
      allow create: if isSignedIn() 
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.id == request.auth.uid;
      allow update: if isOwner(studentProfileId)
                      && isExistingDoc() 
                      && fieldIsImmutable('userId')
                      && fieldIsImmutable('id');
      allow delete: if isOwner(studentProfileId) && isExistingDoc();
    }
    
    /**
     * @description Secures client-specific profile information. Publicly readable for discovery.
     * @path /clientProfiles/{clientProfileId}
     * @principle Data is public-read. Writes are owner-only.
     */
    match /clientProfiles/{clientProfileId} {
      allow get, list: if true;
      allow create: if isSignedIn()
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.id == request.auth.uid;
      allow update: if isOwner(clientProfileId)
                      && isExistingDoc()
                      && fieldIsImmutable('userId')
                      && fieldIsImmutable('id');
      allow delete: if isOwner(clientProfileId) && isExistingDoc();
    }

    /**
     * @description Stores public hackathon event information.
     * @path /hackathons/{hackathonId}
     * @allow (read) Any user, signed in or not, can read hackathon details.
     * @allow (write) Only the authenticated user who created the hackathon can write to it.
     * @principle Data is public-read. Writes are owner-only.
     */
    match /hackathons/{hackathonId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingDoc() && isDocumentOwner();
      allow delete: if isExistingDoc() && isDocumentOwner();
    }
    
    match /hackathons/{hackathonId}/teams/{teamId} {
        allow get: if true; // Teams are public within a hackathon
        allow create: if isTeamMemberOnCreate() && request.resource.data.hackathonId == hackathonId;
        allow update: if isExistingDoc() && isExistingTeamMember() && fieldIsImmutable('hackathonId');
        allow delete: if isExistingDoc() && isExistingTeamMember();
    }

    match /{path=**}/teams/{teamId} {
        allow list: if true;
    }


    /**
     * @description Stores public information about startups.
     * @path /startups/{startupId}
     * @allow (read) Any user, signed in or not, can view startup profiles.
     * @allow (write) Only the authenticated user who created the startup can write to it.
     * @principle Data is public-read. Writes are owner-only.
     */
    match /startups/{startupId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingDoc() && isDocumentOwner();
      allow delete: if isExistingDoc() && isDocumentOwner();
    }

    /**
     * @description Stores public profiles for team members, linkable to multiple startups.
     * @path /team_members/{teamMemberId}
     * @allow (read) Any user, signed in or not, can view team member profiles.
     * @allow (write) Only the authenticated user associated with the team member profile can write to it.
     * @principle Data is public-read. Writes are owner-only.
     */
    match /team_members/{teamMemberId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isExistingDoc() && isDocumentOwner();
    }
  }
}
